C# 합본
220413
C#
기본 출력문 ( Console.WriteLine( ) )
기본 입력문 ( Console.ReadLine( ) )

형변환(Casting)
암시적 변환 – 범위가 작은 데이터 타입의 변수를 큰 데이터 타입 변수에 대입할 경우
명시적 변환 – 대입할 변수 명 앞에  ( )  괄호를 이용하여 사용할 자료형을 직접 명시해 주는 것

int n = 5
int – 예약어 ( 미리 정해져 있는 것 )
n – 식별자 ( 사용자가 이름 짓는 것 )	(변수)
5 – 리터럴 ( 소스코드에 포함된 값 )


닷넷에서 변수의 종류는 크게 (값 형식, 참조 형식) 변수로 나뉜다.

값 형식 – 값 자체가 스택 메모리에 할당되고 변수는 그 메모리를 가리키는 식별자
참조 형식 – 값은 힙 메모리에 할당되고 그 힙 메모리의 주소가 스택 메모리에 할당된다. (변수는 스택 메모리를 가리킨다) ( null로 할당하지 않을 경우 스택 메모리에 null 값 가지며 힙은 없다)

각 형식의 변수를 다른 변수에 대입 할 경우
값 형식 - 스택에 있는 값 자체가 복사되어 다른 스택 메모리에 할당 (스택 2 개)
참조 형식 – 스택에 있는 힙메모리 주소값이 복사되어 다른 스택 메모리에 할당(힙 1개 스택 2개)

값 형식 변수 초기화 - 0으로 초기화가 기본 ( bool – false / int – 0 / string – null )



상수 – 한번 대입되면 이후 변경 불가
const 예약어 


연산자
참 거짓으로 결과 나타남

&& - 논리곱(AND) 연산자
 || - 논리합(OR) 연산자


continue 문
반복 구문에서 continue 문을 이용하여 반복 조건으로 바로 실행을 옮길 수 있다.


Singleton 클래스
클래스가 최초 한번만 메모리 할당(static). 인스턴스를 딱 한개만 만들 때 사용
클래스 자기자신을 멤버로 선언해서 객체를 생성하여 메모리에 둔다(static)
외부에서 멤버로 선언된 객체를 가져올 수 있는 메서드


정적 메서드(static method)
new로 객체 생성 없이 [클래스이름].[정적메서드] 로 호출이 가능
정적 메서드로는 인스턴스 멤버에 접근이 불가능 ( new로 객체 생성이 없기 때문 )

정적 생성자
기본 생성자에 static 예약어 붙임
클래스 객체 생성시 가장 먼저 실행됨.( 단 한 번 )


FQDN ( Fully Qualified Domain Name )
클래스명에 네임스페이스까지 함께 지정하는 경우 / 전부 다 표기
ex ) Console -> System.Console


클래스 내부 – 기본 접근 제한자
클래스 내부 멤버 – private ( 내부에서만 접근 허용 )
클래스 내부 클래스 – internal (동일 프로젝트 내에서 public에 준한 접근)


접근자, 설정자 (get, set)
int A = 0;

public int GetXX( )
{ return A; }

public void SetXX( int value )
{ A = value; }



클래스 내부에 구현 해두면

[객체이름].A = XXX;	방식으로 Set
int B = [객체이름].A ; 	방식으로 Get 이 가능.


프로퍼티
접근자 설정자를 간편하게 나타냄 (메서드의 특수한 변형)

int A = 0;
public int AA

{	get { return A; }
set { A = value; }		} 로 표기되며 사용 방식은 동일



상속

class A
{
}
class B : A		-> A클래스를 상속받음
{
}

수퍼(부모)클래스가 갖고 있는 기능을 접근제한자에 맞추어 사용 가능.
(protected – 서브(자식)클래스에게는 허용)

-	sealed 예약어 ( 상속받지 못하도록 제한 )
-	C#은 클래스 다중상속을 지원하지 않는다.


클래스의 형변환
자식클래스 객체를 생성하고 이걸 부모클래스 객체에 대입하면 암시적인 형변환이 가능하다.
하지만 부모클래스의 객체를 생성하고 이걸 자식클래스로 강제 캐스팅하여 대입하면 컴파일은 가능하지만 실행 시 오류가 발생한다.

-	자식 클래스에 자식클래스만이 갖고 있는 메서드와 멤버가 있을 수 있다.
-	처음 생성한 부모 클래스에는 해당 기능들이 없으므로 이 클래스를 자식클래스에 대입하면 대응 불가능한 부분이 있기 때문.

as, is 연산자
as : (형변환 대상)클래스객체 as (형변환 목표)클래스명
같은 방식으로 사용하며 참조형 변수에만 사용이 가능하다.
클래스 형변환이 가능하면 지정된 타입의 인스턴스값을 반환하고, 가능하지 않으면 null을 반환한다.	-> 결과값 반환

is : 형변환의 가능성 여부를 bool 형태로 나타냄
참조형, 값 형식 모두에 사용 가능 – 단순히 가능한지 여부만 리턴한다.



System.Object 클래스
System.ValueType – bool / sbyte, byte / short, ushort / int, unit / long, ulong / float, double/ decimal / char
위 타입은 Object클래스를 상속받는 값 형식의 타입
그 이외는 전부 참조 형식이라고 생각하자 (ex. string, class .. )

Object 클래스의 4개 public 메서드
public virtual bool Equals( object obj ) ;
public virtual int GetHashCode( ) ;
public Type GetType ( ) ;
public virtual string ToString ( ) ;


-	ToString
~ ToString 메서드 호출하면 해당 인스턴스가 속한 클래스의 전체이름(FQDN) 을 반환한다.
~ 자식클래스에서 기능 재정의가 될 수 있다. C#에서 제공되는 기본 타입(short, int...) 등등에는 클래스 전체 이름이 아니라 해당 타입이 담고 있는 값을 리턴한다.

-	GetType
~ Type type = 클래스객체명.GetType( ) ; 과 같은 방식으로 type 변수에 담으면
type.FullName , type.IsClass, type.ISArray 등 프로퍼티 호출 가능
~ 자식클래스에서 재정의 되면 클래스 타입에 대해 전체 이름을 반환한다 (ex. System.Int32)
~ Type type = typeof( 클래스 이름 ) ;  으로 곧바로 Type을 구하는 방법도 있다.

-	Equals
~ 값과 비교한 결과를 bool 형태로 리턴함.
~ 값 형식은 값을 비교, 참조 형식은 할당된 메모리 위치가 같은지 비교(같은 힙 위치를 가리키면 TRUE)
~ string 타입은 Equals를 재정의하여 객체를 비교하여 같은 텍스트면 TRUE를 반환한다.


-	GetHashCode
~ 특정 인스턴스를 고유하게 식별할 수 있는 4바이트 int 값을 반환함.
~ Equals 매서드와 연계 – Equals 반환값이 False면 GetHashCode 반환값도 다르다.
   Equals 메서드가 재정의 되면 GetHashCode 도 재정의 한다.
~ 일부 자료형은 담고있는 값 자체가 HashCode 로 지정된다 (ex. int)



System.Array
모든 배열의 최상위 클래스

Array 타입 멤버
-	Rank : 배열 인스턴스의 차원(dimension) 수 반환
-	Length : 배열 인스턴스의 요소(element) 수 반환
-	Sort : 배열 요소를 값 순서대로 정렬
-	GetValue : 지정된 인덱스의 배열 요소 값을 반환
-	Copy : 배열내용을 다른 배열에 복사


this, base 예약어
this – 클래스 내부에서 자기 자신을 가리킴
base – 클래스 내부에서 상속받은 부모 클래스를 가리킴



다형성
메서드 오버라이드
부모 클래스에 있는 메서드를 자식 클래스에서 사용할 때( 자식클래스에서 재정의한 메서드로 사용하고 싶을 때 )
부모 클래스에 있는 메서드에 virtual 키워드 붙이고
자식 클래스에 부모클래스 메서드를 가져와서 override 키워드를 붙이면

자식 클래스가 부모 타입으로 형변환 되더라도 자식 클래스는 본인의 메서드를 호출한다.
부모 클래스에 virtual(가상) 메서드로 선언되었기 때문.

자식 클래스에서 의도적으로 같은 이름의 메서드를 만들었다고 할 때는 new 예약어를 이용해서 선언할 수 있다.

메서드 오버로드
메서드 시그니처 – 이름, 반환타입, 매개변수의 수, 개별 매개변수 타입
메서드 시그니처를 다르게 하여 메서드 명은 같으나 다른 기능을 하게 만드는 방법.

연산자 오버로드
public static 타입 operator 연산자(타입1 변수명1, 타입2 변수명2)
와 같은 형태로 구현 가능.


클래스 간의 형변환
동일한 타입을 각각의 클래스가 사용하여 일어날 수 있는 혼선을 방지하기 위해
각 클래스가 사용하는 타입을 정의하여 클래스화 시키면 구분이 쉬워진다.

이 클래스 간의 형변환이 필요할 때.

explicit(명시적), implicit(암시적) 키워드를 이용해서
public class 클래스명A{
static public implicit operator 클래스명B(클래스명A 객체명)
{ return new 클래스명A(객체명.메서드 등) ;
}
}
으로 객체 생성하고 형변환 시킬 때 해당 메서드를 이용하여 자체적으로 변환을 구현할 수 있다.
 
220414
C#
기본 출력문 ( Console.WriteLine( ) )
기본 입력문 ( Console.ReadLine( ) )

형변환(Casting)
암시적 변환 – 범위가 작은 데이터 타입의 변수를 큰 데이터 타입 변수에 대입할 경우
명시적 변환 – 대입할 변수 명 앞에  ( )  괄호를 이용하여 사용할 자료형을 직접 명시해 주는 것

int n = 5
int – 예약어 ( 미리 정해져 있는 것 )
n – 식별자 ( 사용자가 이름 짓는 것 )	(변수)
5 – 리터럴 ( 소스코드에 포함된 값 )


닷넷에서 변수의 종류는 크게 (값 형식, 참조 형식) 변수로 나뉜다.

값 형식 – 값 자체가 스택 메모리에 할당되고 변수는 그 메모리를 가리키는 식별자
참조 형식 – 값은 힙 메모리에 할당되고 그 힙 메모리의 주소가 스택 메모리에 할당된다. (변수는 스택 메모리를 가리킨다) ( null로 할당하지 않을 경우 스택 메모리에 null 값 가지며 힙은 없다)

각 형식의 변수를 다른 변수에 대입 할 경우
값 형식 - 스택에 있는 값 자체가 복사되어 다른 스택 메모리에 할당 (스택 2 개)
참조 형식 – 스택에 있는 힙메모리 주소값이 복사되어 다른 스택 메모리에 할당(힙 1개 스택 2개)

값 형식 변수 초기화 - 0으로 초기화가 기본 ( bool – false / int – 0 / string – null )



상수 – 한번 대입되면 이후 변경 불가
const 예약어 


연산자
참 거짓으로 결과 나타남

&& - 논리곱(AND) 연산자
 || - 논리합(OR) 연산자


continue 문
반복 구문에서 continue 문을 이용하여 반복 조건으로 바로 실행을 옮길 수 있다.


Singleton 클래스
클래스가 최초 한번만 메모리 할당(static). 인스턴스를 딱 한개만 만들 때 사용
클래스 자기자신을 멤버로 선언해서 객체를 생성하여 메모리에 둔다(static)
외부에서 멤버로 선언된 객체를 가져올 수 있는 메서드


정적 메서드(static method)
new로 객체 생성 없이 [클래스이름].[정적메서드] 로 호출이 가능
정적 메서드로는 인스턴스 멤버에 접근이 불가능 ( new로 객체 생성이 없기 때문 )

정적 생성자
기본 생성자에 static 예약어 붙임
클래스 객체 생성시 가장 먼저 실행됨.( 단 한 번 )


FQDN ( Fully Qualified Domain Name )
클래스명에 네임스페이스까지 함께 지정하는 경우 / 전부 다 표기
ex ) Console -> System.Console


클래스 내부 – 기본 접근 제한자
클래스 내부 멤버 – private ( 내부에서만 접근 허용 )
클래스 내부 클래스 – internal (동일 프로젝트 내에서 public에 준한 접근)


접근자, 설정자 (get, set)
int A = 0;

public int GetXX( )
{ return A; }

public void SetXX( int value )
{ A = value; }



클래스 내부에 구현 해두면

[객체이름].A = XXX;	방식으로 Set
int B = [객체이름].A ; 	방식으로 Get 이 가능.


프로퍼티
접근자 설정자를 간편하게 나타냄 (메서드의 특수한 변형)

int A = 0;
public int AA

{	get { return A; }
set { A = value; }		} 로 표기되며 사용 방식은 동일



상속

class A
{
}
class B : A		-> A클래스를 상속받음
{
}

수퍼(부모)클래스가 갖고 있는 기능을 접근제한자에 맞추어 사용 가능.
(protected – 서브(자식)클래스에게는 허용)

-	sealed 예약어 ( 상속받지 못하도록 제한 )
-	C#은 클래스 다중상속을 지원하지 않는다.


클래스의 형변환
자식클래스 객체를 생성하고 이걸 부모클래스 객체에 대입하면 암시적인 형변환이 가능하다.
하지만 부모클래스의 객체를 생성하고 이걸 자식클래스로 강제 캐스팅하여 대입하면 컴파일은 가능하지만 실행 시 오류가 발생한다.

-	자식 클래스에 자식클래스만이 갖고 있는 메서드와 멤버가 있을 수 있다.
-	처음 생성한 부모 클래스에는 해당 기능들이 없으므로 이 클래스를 자식클래스에 대입하면 대응 불가능한 부분이 있기 때문.

as, is 연산자
as : (형변환 대상)클래스객체 as (형변환 목표)클래스명
같은 방식으로 사용하며 참조형 변수에만 사용이 가능하다.
클래스 형변환이 가능하면 지정된 타입의 인스턴스값을 반환하고, 가능하지 않으면 null을 반환한다.	-> 결과값 반환

is : 형변환의 가능성 여부를 bool 형태로 나타냄
참조형, 값 형식 모두에 사용 가능 – 단순히 가능한지 여부만 리턴한다.



System.Object 클래스
System.ValueType – bool / sbyte, byte / short, ushort / int, unit / long, ulong / float, double/ decimal / char
위 타입은 Object클래스를 상속받는 값 형식의 타입
그 이외는 전부 참조 형식이라고 생각하자 (ex. string, class .. )

Object 클래스의 4개 public 메서드
public virtual bool Equals( object obj ) ;
public virtual int GetHashCode( ) ;
public Type GetType ( ) ;
public virtual string ToString ( ) ;


-	ToString
~ ToString 메서드 호출하면 해당 인스턴스가 속한 클래스의 전체이름(FQDN) 을 반환한다.
~ 자식클래스에서 기능 재정의가 될 수 있다. C#에서 제공되는 기본 타입(short, int...) 등등에는 클래스 전체 이름이 아니라 해당 타입이 담고 있는 값을 리턴한다.

-	GetType
~ Type type = 클래스객체명.GetType( ) ; 과 같은 방식으로 type 변수에 담으면
type.FullName , type.IsClass, type.ISArray 등 프로퍼티 호출 가능
~ 자식클래스에서 재정의 되면 클래스 타입에 대해 전체 이름을 반환한다 (ex. System.Int32)
~ Type type = typeof( 클래스 이름 ) ;  으로 곧바로 Type을 구하는 방법도 있다.

-	Equals
~ 값과 비교한 결과를 bool 형태로 리턴함.
~ 값 형식은 값을 비교, 참조 형식은 할당된 메모리 위치가 같은지 비교(같은 힙 위치를 가리키면 TRUE)
~ string 타입은 Equals를 재정의하여 객체를 비교하여 같은 텍스트면 TRUE를 반환한다.


-	GetHashCode
~ 특정 인스턴스를 고유하게 식별할 수 있는 4바이트 int 값을 반환함.
~ Equals 매서드와 연계 – Equals 반환값이 False면 GetHashCode 반환값도 다르다.
   Equals 메서드가 재정의 되면 GetHashCode 도 재정의 한다.
~ 일부 자료형은 담고있는 값 자체가 HashCode 로 지정된다 (ex. int)



System.Array
모든 배열의 최상위 클래스

Array 타입 멤버
-	Rank : 배열 인스턴스의 차원(dimension) 수 반환
-	Length : 배열 인스턴스의 요소(element) 수 반환
-	Sort : 배열 요소를 값 순서대로 정렬
-	GetValue : 지정된 인덱스의 배열 요소 값을 반환
-	Copy : 배열내용을 다른 배열에 복사


this, base 예약어
this – 클래스 내부에서 자기 자신을 가리킴
base – 클래스 내부에서 상속받은 부모 클래스를 가리킴



다형성
메서드 오버라이드
부모 클래스에 있는 메서드를 자식 클래스에서 사용할 때( 자식클래스에서 재정의한 메서드로 사용하고 싶을 때 )
부모 클래스에 있는 메서드에 virtual 키워드 붙이고
자식 클래스에 부모클래스 메서드를 가져와서 override 키워드를 붙이면

자식 클래스가 부모 타입으로 형변환 되더라도 자식 클래스는 본인의 메서드를 호출한다.
부모 클래스에 virtual(가상) 메서드로 선언되었기 때문.

자식 클래스에서 의도적으로 같은 이름의 메서드를 만들었다고 할 때는 new 예약어를 이용해서 선언할 수 있다.

메서드 오버로드
메서드 시그니처 – 이름, 반환타입, 매개변수의 수, 개별 매개변수 타입
메서드 시그니처를 다르게 하여 메서드 명은 같으나 다른 기능을 하게 만드는 방법.

연산자 오버로드
public static 타입 operator 연산자(타입1 변수명1, 타입2 변수명2)
와 같은 형태로 구현 가능.


클래스 간의 형변환
동일한 타입을 각각의 클래스가 사용하여 일어날 수 있는 혼선을 방지하기 위해
각 클래스가 사용하는 타입을 정의하여 클래스화 시키면 구분이 쉬워진다.

이 클래스 간의 형변환이 필요할 때.

explicit(명시적), implicit(암시적) 키워드를 이용해서
public class 클래스명A{
static public implicit operator 클래스명B(클래스명A 객체명)
{ return new 클래스명A(객체명.메서드 등) ;
}
}
으로 객체 생성하고 형변환 시킬 때 해당 메서드를 이용하여 자체적으로 변환을 구현할 수 있다.
 
220415
구조체
class -> struct
1. 기본 생성자는 명시적으로 정의할 수 없다.
2. 매개변수 갖는 생성자 정의해도 기본 생성자가 컴파일러 의해 자동 포함
3. 매개변수 받는 생성자는 해당 코드 내에서 구조체 모든 필드 값 해당해야함

구조체 인스턴스를 클래스 처럼 new로 생성하는 것과
그냥 (구조체명 이름)으로 선언하는 것과 동일하다.	(값 형식 변수 0으로 초기화 됨)

int, double 등 기본형도 동일하게 new로 할당 가능

	메모리 상태가 0으로 초기화 되지만 직접 명시적으로 0을 할당해주어야 컴파일러가 오류라고 판단하지 않는다.
클래스 – 참조형
구조체 – 값 형식


깊은복사 & 얕은복사

구조체 v2 = v1(구조체)	- 깊은 복사
클래스 a2 = a1(클래스)	- 얕은 복사

구조체의 경우 값 형식으로 처음 v1 선언 시 스택 메모리에 값이 저장된다.
이후 인스턴스가 가진 메모리 자체가 복사되어 v2 스택에 값이 복사되어 저장됨.

클래스의 경우 a1 선언 시 힙 메모리에 값이 저장되고 그 힙 주소가 스택에 저장되는데
대입하게 되면 스택에 있는 힙 메모리 주소가 복사되어 a2 스택에 값이 저장된다.

따라서 깊은 복사가 나타나는 구조체의 경우 값을 바꿔주어도 복사된 구조체에서의 값에는 영향을 미치지 않는다.
얕은 복사가 일어나는 클래스는 값을 바꿔주면 복사된 구조체가 가리키는 주소의 값이 변경된 것이므로 전부 변경되게 된다.

메서드에 매개변수로 넘기게 되어도 구조체의 경우는 기존 값에는 변화가 없기 때문에 메서드에서 구조체 값이 변경되어도 기존 값에는 변화가 없다. (단, 값이 복사되어 또 다른 인스턴스는 생성된다.)
클래스의 경우에는 매개변수로 보내면 두개의 변수가 같은 인스턴스를 가리키므로(참조 주소만 전달 된 것) 메서드에서 값이 변경되면 기존 값 또한 변경된다.



ref 예약어
앞서 깊은 & 얕은 복사와 같이 스택의 값, 스택의 힙주소값 등등 “변수의 스택 값”이 복사되는 상황을 CBV : Call by Value
변수의 스택 값 복사 대신에 변수의 스택 값을 담고 있는 주소 자체가 바로 전달되는 CBR : Call by Reference (스택 메모리 한 개만 사용한다는 의미)
참조에 의한 호출을 지원하기 위한 ref, out 두가지 예약어가 있다.

ref 예약어는 1. 메서드의 매개변수를 선언할 때 함께 표기
	    2. 해당 메서드를 호출하는 측에서도 명시해야 함

구조체에 ref 예약어를 사용하면(메서드 선언, 메서드 호출 부 각각)
얕은 복사처럼 결과가 나타난다. (메서드에서 변경 된 값으로 출력 됨)

구조적으로는 메서드의 변수가 호출하는 측 변수와 동일한 주소를 가리키게 된다.
메서드 호출부에 있는 변수 주소를 메서드 선언 부 매개변수가 가리킨다.

참조형 변수에도 사용할 수 있는데 그 경우 힙에 값이 저장되고 그 힙의 주소값이 스택에 저장 까지는 동일,
대입을 하면 주소값이 저장된 스택이 복사되는 것이 아니라. 주소값이 저장된 스택의 주소값을 바로 가리키게 되는 것.

(참조형인 클래스 – 값을 null로 보내면 값이 없으므로 힙에 값이 없이 스택에 null이 저장되는데, 얕은 복사가 실행되면 이 null 값을 가진 스택 메모리가 하나 더 사용 되는 것.
그래서 복사가 이루어진 메모리에 값을 넣게 되면 힙에 값이 들어가고 이 힙의 주소를 가리키는 것으로 변경된다.) – ref 명령어 쓰면 null 가진 스택 메모리 하나만 사용 함.

-	기본 자료형도 ref 사용하면 외부 변수도 값 변경이 된다.
-	ref 인자로 전달되는 변수는 호출 측에서 값을 할당해 두어야만 한다. (호출 전에)



out 예약어
ref와 차이점
1.	out으로 지정된 인자에 넘길 변수는 초기화 하지 않아도 된다. / 초기화 되어 있어도 out 인자 받는 메서드에서는 값 사용 불가
2.	out으로 지정된 인자를 받는 메서드는 반드시 변수에 값을 넣어서 반환해야 함

out예약어는 ref 예약어 기능을 몇가지 강제로 제한한 것

메서드 선언시에 매개변수로 out 예약어가 붙은 결과값을 추가한다.
메서드 정의 부분에서 결과값은 초기화가 되어 있어야 한다 (반환해야 하므로)

메서드 호출 시에 변수를 하나 만들어두고 out 예약어가 붙은 결과 반환위치에 넣어두면 그 변수에 결과값이 반환된다.
ex) tryParse( ) 와 같은 메서드 활용하면 스트링 값을 원하는 자료형으로 바꾸어 바로 출력 가능

ref – 메서드 호출 측에서 변수 값을 초기화 해서 메서드 측에 값 전달. (호출 측 -> 선언 측)
out – 메서드 측에서 반드시 값을 할당해서 반환하여 매서드 호출 측에 값 전달 (선언 -> 호출)




열거형
값 형식 중 하나
byte, sbyte, short, ushort, int, uint, long, ulong -> 상속받아서 정의할 수 있는 사용자 정의 타입

(접근제한자 enum 타입명) 으로 선언하며
내부 구현부에 식별자 이름을 나열하면 각 index가 0부터 차례대로 부여된다. (값 개별 지정 가능)

열거형 객체를 생성하고 특정 식별자를 대입한 후, 객체를 출력하면 식별자 값이 문자열로 출력되는데
enum은 Object 클래스를 상속받고 있고 ToString( ) 메서드를 재정의 하여 숫자가 아닌 문자열로 반환하도록 되어 있기 때문이다.

enum 타입 정의 시 윗줄에 [Flags] 를 작성해서 지정하면
여러 개 식별자가 각각 문자열로 출력된다. (인스턴스가 여러개 값을 포함하는 용도로 사용된다는 것을 알려주기 위한 것)




멤버 유형 확장

읽기 전용 필드
프로퍼티를 이용해서 필드 값을 읽기만 가능하게 외부 노출이 가능한 것처럼
클래스 내부에서도 읽기만 가능하게 만드는 방법.
한번만 값을 초기화하고 다시 설정하지 못하게 하는 방법
readonly 예약어 사용하여 읽기전용 필드 정의하기

	변수를 정의할 때 값을 대입하고, 생성자에서 초기화하면 값이 생성자 초기화 값으로 출력된다

상수
리터럴에 식별자를 붙인 것
변수 - 변하는 값을 고정된 식별자로 가리키는 것
상수 – 변하지 않는 값(리터럴)을 식별자로 재사용할 수 있게 만들어주는 것

const 예약어를 사용해서 상수 선언할 수 있다.
1.	내부에서 자동으로 static이 되므로 static 예약어가 허용됮 ㅣ않는다.
2.	기본 자료형만 상수 정의가 허용된다
3.	상수정의와 함께 값을 대입해야함 (생성자에서 접근 불가)
4.	상수는 컴파일 시에 해당 소스코드에 값이 치환되는 방식.
MinValue, MaxValue 라는 공통 상수 기본제공


이벤트 – 나중에 Study
event 예약어를 사용
콜백패턴 구현 시 코드 줄일 수 있다.



인덱서
배열 요소 접근할 때 사용(this 예약어 이용)
(배열에서 [ ] 대괄호 연산자와 같은 구문을 클래스에서 사용하려면)

this [int index] 와 같은 방식으로 클래스 내부에서 선언해두면
프로퍼티 등을 이용해서 배열 내부 인덱스에 접근할 수 있다.

this[string propertyName] 등으로 int가 아니어도 가능하며
안에 get 프로퍼티와 switch 문을 이용하면 작성한 string 텍스트에 따라서 원하는 멤버변수만 출력할 수 있다.


